- TCP stack
    - close: should send FIN if connected
    - receiving fin: 4way close. close the socket

    - getMessage: get one message
        - tcp_process()
            - loops through socket list and places message in its
              ringbuffer if port/ip and msgtype matches
            - update ack number
        - will need to reconstruct message up to message length.
        - systemlib implementation
    - write(s,buf,size)
        - send_tcp_message will need to fragment if packet too big
          Will need to do that without blocking
        - systemlib implementation
    - listen(s,port,ip) and acceptConnection()
    - make telnet application
    - arp_getMAC should not block.
        Upon connecting a socket, ARP discovery and DNS resolution
        might need to be performed. DNS resolution will be left to 
        the user to do. connect() will require an IP address. Upon
        connect, the socket will be placed in "arp discovery" state.
        The MAC address will be fetched from the cache or a discovery
        will be sent. Upon receiving an ARP reply, or any other ARP
        cache entry addition, the stack will search through the
        socket list for sockets that are waiting for that entry.
        The connection will then be resumed. Once the an ARP entry
        is found for a socket, it will be saved in the socket and
        reused for all remaining transmission.
    - dns resolution for connect()


- hexdump app: should be able to pass filename through command-line params
    - should get pushed on stack?
    - or just the pointer to string passed? but that new process
      might not have access right to mirrorspace

------------ To do later -------------------------------
- fat32 driver
- currently, ring3 apps can access kernel mem since kernel mem is not protected.
    lock kernel code, bios area, kernel data, IDT (read only)
    video mem, page tables
- block cache: the block cache is not multi-cpu friendly (see doc/blockcache)
    would need a test suite to handle all normal cases and concurrency cases
- memory pool: use it in block cache
- serial port: can feed console like keyboard, could make a separate flush function
- IRQ sharing is inneficient: ie: rtl8139 loops trhough 32 devices and checks ISR
    should stop looping when seeing first empty device and and should check ISR faster
- kernel pages should have global flag to avoid polluting the TLB
- Possible bugs:
    -   If a process has two virt page that maps to the same phys and the thread dies,
        we will free all pages. But if we free the first mapping, then another CPU maps it
        when we arrive at the second mapping we will free it again, so other thread will lose it
    - creating more consoles than what is allowed has no error handling
- see memorymanagement in doc folder
===================== Cool stuff to try =====================
- TCP/IP, and telnet shell
- usb driver
- disk should be partitioned with MBR
    bootloader in MBR and kernerl in partition 1   
- virtualization (nested virtualization??)

======================================================================================
Current network implementation:

receiving a message:
the netcard abstraction's net_process() function, invoked
by the softirq, agglomerates messages from all netcards and
distributes them to the ICMP or IP handlers.

The ICMP handler responds immediately to ping requests. The IP
handler forwards the message to the TCP or UDP handlers. The
UDP handler is not implemented yet. The TCP handler forwards
the message to active sockets by finding the socket listening
to the port and ip of the message. The message is added in 
the socket's message queue while locking the list

sending a message
the netcard abstraction's net_send() function locks
the netcard implementation's send spinlock.

net_send() takes an interface index as destination parameter.
ip_send takes an ip address as destination parameter. ip_send
invokes ip_routing_route() to determine on what netcard
to send the message based the destination address.








