- hypervisor
    publish entire code base on github
        link to it in article
    advertise on osdev    
    enable vpid with vpid==1

    event injection
        reflecting exceptions and interrupts to VM: 31.7
        transparently inject back all exceptions inside VM and do VMRESUME

    invalidate EPT tlb entries:
        on guest-physical remapping, invalidate EPT on all other host CPUs.
        when destroying a VM, invalidate all mappings for that EPT
        emulate guest invlpg and invpcid

    multiple vcpu
    virtual apic
    virtio device
    bios

- memory:
    free:
        When the process starts, it's heap is just a big chunk of unallocated memory.
        As malloc is called, some pages are reserved in that area.
        Free will inform the kernel about what page is the last one used in the heap after 
        the request buffer is freed. So the kernel will release all pages in the heap that
        resides after that page. 
    **** implement release_pages in mmu.S

    system_reclaim_memory:
        invoke memory_pool_reclaim 
    balloon driver:
        reclaim mem
        tell host what pages are not present

- how to make thread sleep and wakeup upon HW event or mutex unlock?
    - also robust in case of crash
- raid layer

- USB (to access usb serial port?)

- sockets still needs a lot of improvements (doc/net)
    - fsm for tcp ?
------------ To do later -------------------------------
- GUI
- networking
    - arp_getMAC should not block.
    - udp sockets
    - dns resolution before connect() (connect would always require ip)
    - DHCP
- hexdump app: should be able to pass filename through command-line params
    - should get pushed on stack?
    - or just the pointer to string passed? but that new process
      might not have access right to mirrorspace
- serial port: can feed console like keyboard, could make a separate flush function
- Possible bugs:
    -   If a process has two virt page that maps to the same phys and the thread dies,
        we will free all pages. But if we free the first mapping, then another CPU maps it
        when we arrive at the second mapping we will free it again, so other thread will lose it
    - creating more consoles than what is allowed has no error handling
- low priority:
    - currently, ring3 apps can access kernel mem since kernel mem is not protected.
        lock kernel code, bios area, kernel data, IDT (read only)
        video mem, page tables
    - kernel pages should have global flag to avoid polluting the TLB
    - IRQ sharing is inneficient: ie: rtl8139 loops trhough 32 devices and checks ISR
        should stop looping when seeing first empty device and and should check ISR faster
    - see memorymanagement in doc folder
- fat32 driver
    - make real partionned drive
    - change bootloader
===================== Cool stuff to try =====================
- usb driver
- disk should be partitioned with MBR
    bootloader in MBR and kernel in partition 1   
======================================================================================
document:
    block cache (and why ssd would become irrelevant)
    soft IRQ
    networking (see doc/net)

Using an entry safely when another thread wants to delete it.
    The hashtable has a visit(uint64_t keysize, uint64_t* key,void(*visitor)(void*)) function. 
    The visit() function will find the node with
    associated key and will invoke visitor(node.data). During the functor execution, 
    the bucket will be readlocked. This will ensure that no other thread can remove the entry while the
    functor is called, therefore while the object is used. So it is safe to remove an object from the
    hash table and delete it right after since removing the object from the list guarantees that no 
    other thread is using it.

remove and delete object with specific PID scan_and_remove
    visit all nodes
        writelock the bucket
        invoke functor that will evaluate PID, release mem and return true/false
        if returned true, remove node.
        release writelock

