- virtio network card driver
    when receiving a buffer, the system crashes
    try to ping

- virtio block device
- sockets still needs a lot of improvements (doc/net)
    - fsm for tcp ?

- fat32 driver
    - make real partionned drive
    - change bootloader

------------ To do later -------------------------------
- networking
    - arp_getMAC should not block.
    - udp sockets
    - dns resolution before connect() (connect would always require ip)
    - DHCP
- mem pool: invoke memory_pool_reclaim when running low on mem
- hexdump app: should be able to pass filename through command-line params
    - should get pushed on stack?
    - or just the pointer to string passed? but that new process
      might not have access right to mirrorspace
- how to make thread sleep and wakeup upon HW event or mutex unlock?
- serial port: can feed console like keyboard, could make a separate flush function
- Possible bugs:
    -   If a process has two virt page that maps to the same phys and the thread dies,
        we will free all pages. But if we free the first mapping, then another CPU maps it
        when we arrive at the second mapping we will free it again, so other thread will lose it
    - creating more consoles than what is allowed has no error handling
- low priority:
    - currently, ring3 apps can access kernel mem since kernel mem is not protected.
        lock kernel code, bios area, kernel data, IDT (read only)
        video mem, page tables
    - kernel pages should have global flag to avoid polluting the TLB
    - IRQ sharing is inneficient: ie: rtl8139 loops trhough 32 devices and checks ISR
        should stop looping when seeing first empty device and and should check ISR faster
    - see memorymanagement in doc folder
===================== Cool stuff to try =====================
- usb driver
- disk should be partitioned with MBR
    bootloader in MBR and kernel in partition 1   
- virtualization (nested virtualization??)
    - vmx
        - load vmcs with long mode data. boot a vm in long mide
======================================================================================
document:
    block cache (and why ssd would become irrelevant)
    soft IRQ
    networking (see doc/net)

Using an entry safely when another thread wants to delete it.
    The hashtable has a visit(uint64_t keysize, uint64_t* key,void(*visitor)(void*)) function. 
    The visit() function will find the node with
    associated key and will invoke visitor(node.data). During the functor execution, 
    the bucket will be readlocked. This will ensure that no other thread can remove the entry while the
    functor is called, therefore while the object is used. So it is safe to remove an object from the
    hash table and delete it right after since removing the object from the list guarantees that no 
    other thread is using it.

remove and delete object with specific PID scan_and_remove
    visit all nodes
        writelock the bucket
        invoke functor that will evaluate PID, release mem and return true/false
        if returned true, remove node.
        release writelock

