hash optimization:
        compile with optimization
        optimize hash function
        optimize mem references (as less redirection as possible)

------------ To do later -------------------------------
- networking
    - sockets still needs a lot of improvements (doc/net)
    - arp_getMAC should not block.
    - udp sockets
    - dns resolution for connect()
    - DHCP
- mem pool: invoke memory_pool_reclaim when running low on mem
- hexdump app: should be able to pass filename through command-line params
    - should get pushed on stack?
    - or just the pointer to string passed? but that new process
      might not have access right to mirrorspace
- fat32 driver
- serial port: can feed console like keyboard, could make a separate flush function
- Possible bugs:
    -   If a process has two virt page that maps to the same phys and the thread dies,
        we will free all pages. But if we free the first mapping, then another CPU maps it
        when we arrive at the second mapping we will free it again, so other thread will lose it
    - creating more consoles than what is allowed has no error handling
- block cache test:
        read from block created by write
        write to read block
        2 writes to same block
        read more entries than cache to test clearCache
- low priority:
    - currently, ring3 apps can access kernel mem since kernel mem is not protected.
        lock kernel code, bios area, kernel data, IDT (read only)
        video mem, page tables
    - kernel pages should have global flag to avoid polluting the TLB
    - IRQ sharing is inneficient: ie: rtl8139 loops trhough 32 devices and checks ISR
        should stop looping when seeing first empty device and and should check ISR faster
    - see memorymanagement in doc folder
===================== Cool stuff to try =====================
- usb driver
- disk should be partitioned with MBR
    bootloader in MBR and kernel in partition 1   
- virtualization (nested virtualization??)
    - vmx
        - load vmcs with long mode data. boot a vm in long mide
======================================================================================



Using an entry safely when another thread wants to delete it.
    The hashtable has a visit(uint64_t keysize, uint64_t* key,void(*visitor)(void*)) function. 
    The visit() function will find the node with
    associated key and will invoke visitor(node.data). During the functor execution, 
    the bucket will be readlocked. This will ensure that no other thread can remove the entry while the
    functor is called, therefore while the object is used. So it is safe to remove an object from the
    hash table and delete it right after since removing the object from the list guarantees that no 
    other thread is using it.

remove and delete object with specific PID scan_and_remove
    visit all nodes
        writelock the bucket
        invoke functor that will evaluate PID, release mem and return true/false
        if returned true, remove node.
        release writelock

