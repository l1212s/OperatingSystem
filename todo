- cleanup doc/net
- physical memory
    sockets and console buffers are created using malloc and then using the mirror address
    but if those buffers span accross pages, the 2nd portion might not map contiguously
    so this would fail. When creating buffers that are shared between processes, we
    should either make sure that the memory will be contigous in physical memory or change
    cr3 before using it.
 
- application
    - web server: serve files from ata disk
    - telnet client application

- hexdump app: should be able to pass filename through command-line params
    - should get pushed on stack?
    - or just the pointer to string passed? but that new process
      might not have access right to mirrorspace

------------ To do later -------------------------------
- networking
    - udp sockets
    - dns resolution for connect()
    - stack stack still needs a lot of improvements (doc/net)
    - arp_getMAC should not block.
- memory pool: continue memorypool.S and use it in send_tcp_message()
- fat32 driver
- currently, ring3 apps can access kernel mem since kernel mem is not protected.
    lock kernel code, bios area, kernel data, IDT (read only)
    video mem, page tables
- block cache: the block cache is not multi-cpu friendly (see doc/blockcache)
    would need a test suite to handle all normal cases and concurrency cases
- serial port: can feed console like keyboard, could make a separate flush function
- IRQ sharing is inneficient: ie: rtl8139 loops trhough 32 devices and checks ISR
    should stop looping when seeing first empty device and and should check ISR faster
- kernel pages should have global flag to avoid polluting the TLB
- Possible bugs:
    -   If a process has two virt page that maps to the same phys and the thread dies,
        we will free all pages. But if we free the first mapping, then another CPU maps it
        when we arrive at the second mapping we will free it again, so other thread will lose it
    - creating more consoles than what is allowed has no error handling
- see memorymanagement in doc folder
===================== Cool stuff to try =====================
- TCP/IP, and telnet shell
- usb driver
- disk should be partitioned with MBR
    bootloader in MBR and kernerl in partition 1   
- virtualization (nested virtualization??)

======================================================================================

TODO: the synack can only be sent when the socket is accepted.
      because we can only create the socket's buffer from the accepting process.

Accepting connections
A socket is created using create_socket(). Then the socket is placed in listening mode with
listen(). listen() will set the source ip/port of the socket as per parameters of the function
and destination ip/port to 0. A backlog buffer is created with size=(sizeof(socket*)*backlogCount).

When a segment is processed by tcp_process (in softirq context), a socket will try to be matched.
If no socket is found then tcp_process() will try to find a listening socket that uses the same
source ip/port (matching the received segment's destination fields) and with destination ip/port set to 0.
if a socket is found, then we know that this segment is for an incomming connection.

The listening socket will only process SYN segments and will ignore any other segments.
When processing a SYN segment, it will create a new socket with the same source ip/port
and with destination ip/port matching the source of the incomming segment. The state will be set
to CONNECTING. The new socket will be saved in the listening socket's backlog. The new socket will 
stay in the backlog until it gets picked up by accept(). accept() will then move the socket to 
the main list. The socket created in the backlog is only temporary. accept() will create a new
socket instance based on that socket so that the new instance will reside in the accepting 
process's heap.

When the accept function is called, it will go through the backlog of the listening socket
and will finish creating the socket. It will clone the socket and create the receive buffer 
and send the syn/ack. The socket will stay in "CONNECTING" state until it receives the ack 
of the syn/ack accept will move the socket from the backlog to the main list.

s = find_socket(src,dst)
if (s == 0)
    s =find_listening_socket(src,0)

TODO: what if socket in backlog receives a FIN/RST????
