http://www.tldp.org/HOWTO/KernelAnalysis-HOWTO-8.html
http://www.cubrid.org/blog/dev-platform/understanding-tcp-ip-network-stack/
http://1.bp.blogspot.com/_Y6kJq_O7xJw/So8Vg9IQJXI/AAAAAAAAADo/G5Jk-Cjadto/s1600-h/TCP_Ingress_Queuing.png

tcp_v4_do_rcv
    tcp_ack_snd_check 

so the ack is sent from the softIRQ? 
    - but my send function has a lock. We cannot, or should not, lock in the softIRQ.
      because if another thread has that lock we would deadlock.
    - and what if the driver cant send anymore because Q is full? the softIRQ would spin retrying.
    
    - unless we clear interrupts and then spinlock
        1 - spinlock will prevent another CPU from accessing the send function
        2 - the thread could not be preempted on the local CPU so there is no chances
            that a softIRQ would deadlock (since softIIRQ are prioritized over that 
            thread, it could continue to run and never give time to the thread to 
            release the lock). 
        3 - On a single-CPU system, the interrupt cleared and spinlock would be
            redundant but would not cause a problem


Current network implementation:

receiving a message:
the netcard abstraction's net_process() function, invoked
by the softirq, agglomerates messages from all netcards and
distributes them to the ICMP or IP handlers.

The ICMP handler responds immediately to ping requests. The IP
handler forwards the message to the TCP or UDP handlers. The
UDP handler is not implemented yet. The TCP handler forwards
the message to active sockets by finding the socket listening
to the port and ip of the message. The message is added in 
the socket's message queue while locking the list

sending a message
the netcard abstraction's net_send() function locks
the netcard implementation's send spinlock.

net_send() takes an interface index as destination parameter.
ip_send takes an ip address as destination parameter. ip_send
invokes ip_routing_route() to determine on what netcard
to send the message based the destination address.

tcp has no notion of size. A segment is a segment. It is the 
layer7 that is responsible of reconstructing full messages



--------------------------------------------------------------
arp_getMAC should not block:
        Upon connecting a socket, ARP discovery and DNS resolution
        might need to be performed. DNS resolution will be left to
        the user to do. connect() will require an IP address. Upon
        connect, the socket will be placed in "arp discovery" state.
        The MAC address will be fetched from the cache or a discovery
        will be sent. Upon receiving an ARP reply, or any other ARP
        cache entry addition, the stack will search through the
        socket list for sockets that are waiting for that entry.
        The connection will then be resumed. Once the an ARP entry
        is found for a socket, it will be saved in the socket and
        reused for all remaining transmission.


--------------------------------------------------------------
socket locking:
Problem to solve:   1) make sure a thread does not delete its socket while softIRQ is
                       using it.
                    2) a thread might want to get the seqnumber while the softirq is
                       playing with it

solution:           softirq should lock socket. thread should try to lock socket
                    before trying to delete it. then it will delete it and remove
                    it from list. This is a guarantee that no deleted socket will
                    be stored in the list.
                    ANOTHER PROBLEM: if the softIRQ is waiting on socket release
                                     and the thread releases it?

socket list locking:
problem to solve:   make that only one consumer at a time can append/remove from the
                    list.
------------------------

net_send: will send 1 frame of maximum MTU size.
      returns 0 if sending failed or size of frame
      if sending failed. Frames are guaranteed to be sent
      in full

ip_send: will send a packet of maximum 65536 bytes.

if net_send returns 0, because of HW buffer overflow,
then ip_send will return the number of bytes sent. but
tcp_send should not attempt to send the rest of the data
because the IP protocol expects the rest of the packet.

tcp_send: will send 1 segment of maximum 64k







